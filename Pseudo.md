# 슈도코드(의사코드) 작성의 종합 가이드

## 목차
- [슈도코드란?](#슈도코드란)
- [슈도코드 작성 형식](#슈도코드-작성-형식)
- [자주 사용되는 키워드](#자주-사용되는-키워드)
- [슈도코드 작성 예시](#슈도코드-작성-예시)
- [다양한 표현 방식](#다양한-표현-방식)
- [슈도코드 작성 원칙 및 주의사항](#슈도코드-작성-원칙-및-주의사항)
- [실전 팁](#실전-팁)
- [고급 예시](#고급-예시)

## 슈도코드란?
슈도코드(Pseudocode)는 '가짜의(Pseudo) 코드'로, 프로그램이나 알고리즘의 논리적 흐름을 자연어로 표현한 것입니다. 실제 프로그래밍 언어의 문법에 얽매이지 않고 알고리즘을 설계하기 위한 도구입니다.

> 의사코드(슈도코드)는 프로그램을 작성할 때 각 모듈이 작동하는 논리를 표현하기 위한 언어입니다. 특정 프로그래밍 언어의 문법에 따라 쓰인 것이 아니라, 일반적인 언어로 코드를 흉내 내어 알고리즘을 써놓은 코드를 말합니다.

## 슈도코드 작성 형식

### 일반적인 구조
1. **알고리즘 이름과 목적** - 무엇을 하는 알고리즘인지 명시
2. **입력과 출력** - 알고리즘이 받는 입력과 생성하는 출력을 명시
3. **변수 선언** - 필요한 변수들을 설명
4. **단계별 절차** - 알고리즘의 핵심 논리 흐름
5. **종료 조건** - 알고리즘 종료 시점

## 자주 사용되는 키워드

### 입출력 관련
- **입력**: READ, OBTAIN, GET, INPUT
- **출력**: PRINT, DISPLAY, SHOW, OUTPUT

### 제어 흐름
- **계산**: COMPUTE, CALCULATE, DETERMINE
- **초기화**: SET, INIT
- **요소 추가**: INCREMENT, BUMP
- **반복**: WHILE, FOR, REPEAT-UNTIL, DO-WHILE
- **조건문**: IF-THEN-ELSE, CASE, SWITCH
- **논리값**: TRUE, FALSE
- **기타**: BEGIN, END, RETURN, EXCEPTION

## 슈도코드 작성 예시

### 예시 1: 1부터 N까지의 합계 구하기
```
알고리즘: 합계_구하기
입력: 정수 N
출력: 1부터 N까지의 합

BEGIN
    합계 = 0
    
    1부터 N까지의 각 숫자에 대해 순차적으로:
        현재 숫자를 합계에 더함
    
    합계 반환
END
```

### 예시 2: 판매세 포함 물건 값 계산하기
```
알고리즘: 판매세_계산
입력: 물건_가격, 세금_비율
출력: 최종_가격

BEGIN
    물건_가격 입력받기
    세금_비율 입력받기
    
    판매세 = 물건_가격 × 세금_비율
    최종_가격 = 물건_가격 + 판매세
    
    최종_가격 출력
END
```

### 예시 3: 배열에서 최댓값 찾기
```
알고리즘: 최댓값_찾기
입력: 숫자_배열
출력: 최댓값

BEGIN
    최댓값 = 배열의 첫 번째 원소
    
    배열의 두 번째 원소부터 마지막 원소까지 순차적으로:
        현재 원소가 최댓값보다 크면:
            최댓값을 현재 원소로 업데이트
    
    최댓값 반환
END
```

## 다양한 표현 방식

슈도코드는 작성자마다 다르게 표현될 수 있습니다. 슈도코드의 효과적인 표현 방식을 살펴보겠습니다:

### 비효율적인 방식: 프로그래밍 언어와 너무 유사하게
```
// 이 방식은 피해야 합니다! - 실제 코딩과 차이가 없어짐
Function Sum(number) {
    let sum = 0;
    
    for (let i = 1; i <= number; i++) {
        sum = sum + i;
    }
    
    return sum;
}
```

### 효과적인 방식 1: 자연어에 가깝게
```
합계를 계산하는 함수:
    합계를 0으로 초기화한다
    
    1부터 입력받은 숫자까지 반복:
        현재 숫자를 합계에 더한다
    
    합계를 반환한다
```

### 효과적인 방식 2: 간결하면서도 명확하게
```
SUM = 0
FOR i = 1 TO N
    SUM += i
RETURN SUM
```

## 슈도코드 작성 원칙 및 주의사항

### 1. 너무 세세히 작성하지 않기 (가장 중요)
- **핵심 논리에 집중**: 세부 구현보다는 알고리즘의 핵심 아이디어를 표현하는 데 집중
- **코드 수준까지 내려가지 않기**: 변수 선언, 세부 연산자 등 프로그래밍 언어 특정 요소는 생략
- **과도한 설명 피하기**: 명백한 내용은 생략하여 간결함 유지

### 2. 적절한 추상화 수준 유지하기
- **프로그래밍 언어 문법 피하기**: 특정 언어의 문법보다 논리 흐름에 집중
- **알고리즘 단계를 명확히**: 핵심 논리를 파악할 수 있는 적절한 상세 수준 유지

### 3. 일관성과 명확성 유지하기
- **일관된 형식 사용**: 들여쓰기, 키워드 사용에서 일관성 유지
- **명확한 표현 사용**: 다른 사람도 이해할 수 있는 표현 선택
- **불필요한 내용 생략**: 확실한 내용을 여러 번 반복하지 않음

### 4. 프로그래밍 구조 활용하기
- **조건문, 반복문 등의 구조를 적절히 활용**
- **변수 사용은 필요할 때만**: 필수적인 경우에만 변수를 사용하여 간결함 유지

### 5. 사용 목적에 맞게 작성하기
- **목적에 맞는 세부 사항 포함**: 알고리즘 전체를 한눈에 파악할 수 있어야 함
- **실제 코드로 쉽게 변환할 수 있는 수준 유지**

## 실전 팁

### 추상적인 표현, 추측이 필요한 표현은 피하기
```
// 모호한 표현
IF(a % 2 == 0)
FOR i = 1 TO n-1

// 명확한 표현
IF(a가 짝수라면)
FOR i 값을 1부터 (n-1)까지 반복
```

### 기능별로 나누어서 작성하기
```
// 함수명과 목적을 명확히
FUNCTION 합계_계산(숫자_목록):
    [함수 내용]

// 함수 호출 시 목적 명시
합계 = 합계_계산(숫자_목록)
```

### 함수의 경우 매개변수의 이름을 명확히 하기
```
DFS(현재까지_계산된_합계, 현재_노드_번호){
    IF (현재_노드가 마지막 노드라면) 
        RETURN 현재까지_계산된_합계
    ELSE 
        RETURN DFS(현재까지_계산된_합계 + 현재_노드의_값, 다음_노드_번호)
}
```

### 프로그래밍 문법보다 자연어 논리에 집중하기
```
// 프로그래밍 문법에 가까운 표현 (피해야 함)
FOR(i=0; i<배열.length; i++)

// 자연어 논리에 집중한 표현 (권장)
배열의 각 원소에 대해 처음부터 끝까지 순서대로:
    해당 원소에 대한 처리 수행
```

### 너무 세세히 작성하지 않기
```
// 너무 세세한 슈도코드 (피해야 함)
행 = 0
행이 n보다 작은 동안 반복:
    열 = 0 
    열이 m보다 작은 동안 반복:
        입력 받은 값을 지도[행][열]에 저장
        열 = 열 + 1
    행 = 행 + 1

// 적절한 추상화 수준의 슈도코드 (권장)
n x m 크기의 지도 정보를 입력받아 2차원 배열에 저장
```

## 고급 예시

### 예시 4: 이진 탐색 알고리즘
```
알고리즘: 이진_탐색
입력: 정렬된_배열, 검색_값
출력: 검색_값의 인덱스 (없으면 -1)

BEGIN
    왼쪽 = 0
    오른쪽 = 배열의_길이 - 1
    
    왼쪽이 오른쪽보다 작거나 같은 동안 반복:
        중간 = (왼쪽 + 오른쪽) / 2의 내림값
        
        IF 배열[중간] == 검색_값:
            중간 인덱스 반환
        ELSE IF 배열[중간] < 검색_값:
            왼쪽 = 중간 + 1
        ELSE:
            오른쪽 = 중간 - 1
    
    -1 반환 (값을 찾지 못함)
END
```

### 예시 5: 너비 우선 탐색(BFS) 알고리즘
```
알고리즘: BFS
입력: 그래프, 시작_노드
출력: 방문한 노드 목록

BEGIN
    큐 생성
    방문_목록 생성 (빈 배열)
    방문_여부 배열 생성 (모든 값은 FALSE로 초기화)
    
    시작_노드를 큐에 추가
    시작_노드를 방문했다고 표시
    
    큐가 빌 때까지 반복:
        현재_노드 = 큐에서 첫 번째 노드 제거
        방문_목록에 현재_노드 추가
        
        현재_노드의 모든 인접 노드에 대해:
            IF 해당 인접_노드를 아직 방문하지 않았다면:
                인접_노드를 방문했다고 표시
                인접_노드를 큐에 추가
    
    방문_목록 반환
END
```

### 예시 6: 퀵 정렬 알고리즘
```
알고리즘: 퀵_정렬
입력: 배열, 시작_인덱스, 끝_인덱스
출력: 정렬된 배열

FUNCTION 퀵_정렬(배열, 시작, 끝)
    IF 시작 < 끝 THEN
        피봇_인덱스 = 분할(배열, 시작, 끝)
        
        퀵_정렬(배열, 시작, 피봇_인덱스 - 1)
        퀵_정렬(배열, 피봇_인덱스 + 1, 끝)
    END IF
END FUNCTION

FUNCTION 분할(배열, 시작, 끝)
    피봇 = 배열[끝]
    i = 시작 - 1
    
    // 시작부터 (끝-1)까지 각 요소를 확인
    FOR j 값을 시작부터 (끝-1)까지 순차적으로 증가시키며 반복
        IF 배열[j] <= 피봇 THEN
            i 값을 1 증가
            배열[i]와 배열[j] 교환
        END IF
    END FOR
    
    배열[i + 1]와 배열[끝] 교환
    RETURN i + 1
END FUNCTION
```